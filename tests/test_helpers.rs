use image_hosting_server::{
    config::Config,
    database::Database,
    services::redis::RedisService,
    handlers::AppState,
};
use std::sync::Arc;
use uuid::Uuid;

pub async fn setup_test_app_state() -> AppState {
    let config = Config::test_config();
    let database = Database::new_test().await.expect("Failed to create test database");
    let redis = RedisService::new_test().expect("Failed to create test Redis service");
    
    AppState {
        database,
        redis,
        config,
    }
}

pub fn create_test_image_data() -> Vec<u8> {
    // 1x1 pixel PNG for testing
    vec![
        0x89, 0x50, 0x4E, 0x47, 0x0D, 0x0A, 0x1A, 0x0A, 0x00, 0x00, 0x00, 0x0D,
        0x49, 0x48, 0x44, 0x52, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01,
        0x08, 0x02, 0x00, 0x00, 0x00, 0x90, 0x77, 0x53, 0xDE, 0x00, 0x00, 0x00,
        0x0C, 0x49, 0x44, 0x41, 0x54, 0x08, 0xD7, 0x63, 0xF8, 0x00, 0x00, 0x00,
        0x00, 0x01, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x49, 0x45, 0x4E, 0x44, 0xAE, 0x42, 0x60, 0x82
    ]
}

pub fn create_test_jpeg_data() -> Vec<u8> {
    // Minimal JPEG header for testing
    vec![
        0xFF, 0xD8, 0xFF, 0xE0, 0x00, 0x10, 0x4A, 0x46, 0x49, 0x46, 0x00, 0x01,
        0x01, 0x01, 0x00, 0x48, 0x00, 0x48, 0x00, 0x00, 0xFF, 0xDB, 0x00, 0x43,
        0x00, 0x08, 0x06, 0x06, 0x07, 0x06, 0x05, 0x08, 0x07, 0x07, 0x07, 0x09,
        0x09, 0x08, 0x0A, 0x0C, 0x14, 0x0D, 0x0C, 0x0B, 0x0B, 0x0C, 0x19, 0x12,
        0x13, 0x0F, 0x14, 0x1D, 0x1A, 0x1F, 0x1E, 0x1D, 0x1A, 0x1C, 0x1C, 0x20,
        0x24, 0x2E, 0x27, 0x20, 0x22, 0x2C, 0x23, 0x1C, 0x1C, 0x28, 0x37, 0x29,
        0x2C, 0x30, 0x31, 0x34, 0x34, 0x34, 0x1F, 0x27, 0x39, 0x3D, 0x38, 0x32,
        0x3C, 0x2E, 0x33, 0x34, 0x32, 0xFF, 0xC0, 0x00, 0x11, 0x08, 0x00, 0x01,
        0x00, 0x01, 0x01, 0x01, 0x11, 0x00, 0x02, 0x11, 0x01, 0x03, 0x11, 0x01,
        0xFF, 0xC4, 0x00, 0x14, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0xFF, 0xC4,
        0x00, 0x14, 0x10, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xDA, 0x00, 0x0C,
        0x03, 0x01, 0x00, 0x02, 0x11, 0x03, 0x11, 0x00, 0x3F, 0x00, 0xB2, 0xC0,
        0x07, 0xFF, 0xD9
    ]
}

pub fn generate_test_user_email() -> String {
    format!("test_{}@example.com", Uuid::new_v4())
}

pub fn generate_test_filename() -> String {
    format!("test_{}.jpg", Uuid::new_v4())
}

pub async fn cleanup_test_data(database: &Database) {
    // Clean up test data after tests
    let _ = sqlx::query!("TRUNCATE TABLE images, api_keys, users RESTART IDENTITY CASCADE")
        .execute(database.pool())
        .await;
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_create_test_image_data() {
        let data = create_test_image_data();
        assert!(!data.is_empty());
        assert!(data.starts_with(&[0x89, 0x50, 0x4E, 0x47])); // PNG signature
    }

    #[test]
    fn test_create_test_jpeg_data() {
        let data = create_test_jpeg_data();
        assert!(!data.is_empty());
        assert!(data.starts_with(&[0xFF, 0xD8, 0xFF])); // JPEG signature
    }

    #[test]
    fn test_generate_test_user_email() {
        let email1 = generate_test_user_email();
        let email2 = generate_test_user_email();
        
        assert_ne!(email1, email2);
        assert!(email1.contains("@example.com"));
        assert!(email2.contains("@example.com"));
    }

    #[test]
    fn test_generate_test_filename() {
        let filename1 = generate_test_filename();
        let filename2 = generate_test_filename();
        
        assert_ne!(filename1, filename2);
        assert!(filename1.ends_with(".jpg"));
        assert!(filename2.ends_with(".jpg"));
    }
}
